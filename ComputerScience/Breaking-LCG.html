<!DOCTYPE html>
<html lang="en">
	
	<head>
	<meta charset="UTF-8">
	<title>Breaking LCG - Kostis 1101</title>
	<link rel="stylesheet" href="/style.css">
	<link rel="stylesheet" href="/PrismJS/prismjs.css">
	
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>

<body>
	<div id="sidenav-placeholder"></div>
	
	<script src="//code.jquery.com/jquery.min.js"></script>
	<script>
		$.get("../sidebar.html", function(data){
			$("#sidenav-placeholder").replaceWith(data);
		});
	</script>
	
	
	<div class="main">
		Date: 16/03/2024
		<h2 style="text-align: center;">Breaking The Linear Congruential Pseudorandom Number Generator</h2>
		
		<div class="math_text">
			<br>
			<p>
				Recently, through a cryptography course I am taking, I found out about the <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">Linear Congruential Pseudorandom Number Generator (LCG)</a>. It is a simple and really fast pseudorandom number generator perfect for applications where privacy and security are not needed. This is because it can be broken quite easily and thus be predictable. So that's what we are going to to today. We are going to (at least attempt to) break a LCG.
			</p>
			<br>
			<h3>Introduction</h3>
			
			<p>
				The LCG can be defined by the following recursive relation:
				\[
				x_{n + 1} = ax_n + b \mod N
				\]
				where \(x0\), \(a\), \(b\) and \(N\) can be considered part of the seed. In most implementations, however, \(a\), \(b\) and \(N\) are constant and not part of the seed, chosen to optimize for the best possible distribution. For example, most of the times \(N\) is either prime or a power of 2 and a and b are coprime to \(N\).
			</p>
			<p>
				To understand why the LCG is not safe and to try to brake it, we first need to know what does it mean for a pseudorandom number generator to safe in the first place. This is a bit technical and you can read about it more <a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator#Definitions">here</a>, but the overall idea is this: A pseudorandom number generator is safe, if there does not exist any polynomial time algorithm \(A\) that can distinguish between a pseudorandomly generated sequence of numbers from a truly random sequence of numbers. <br>
				An interesting observation one can make is that if a pseudorandom number generator is safe, that essentially means that it can not be reversed very easily. In other words, the problem of computing the pseudorandom numbers from a seed is easy, but the reverse (computing the seed from a pseudorandom sequence) in hard. That reminds me of hash functions. Is there any similarity between them? Since I am not familiar with this topic, I am not sure.
			</p>
			
			<br>
			<h3>Implementing the LCG</h3>
			<p>
				For the purpose of breaking the LCG, we are going to implement it in python. I used a generator to generate the sequence. The code is the following:
				<pre id="codeblock">
					<code class="language-python">
def lcg(x0, a, b, N):
  while True:
    yield x0
    x0 = (a * x0 + b) % N
					</code>
				</pre>
			</p>
			
			<br>
			<h3>An Exploration</h3>
			<p>
				Breaking the LCG just consists of creating a algorithm that can accurately predict whether or not a sequence of numbers is generated by the LCG or not. But we are going to go a bit further. From some given values of the generated sequence we are going to "find" the values for \(a\), \(b\) and \(N\).
			</p>
			<p>
				Let's say we are given the first \(k + 1\) values of the sequence \(x_0, x_1, ..., x_k\), for which the following relation:
				\[
				x_{n + 1} \equiv ax_n + b \pmod N
				\]
				for some \(a, b, N \in \mathbb{N}\). Now define the following sequence:
				\[
				y_n = (x_{n + 1} - x_n) \bmod N
				\]
				This is the difference between two consecutive values of the first sequence. One can easily show that:
				\[
					\begin{flalign*}
						y_{n + 1} &= (x_{n + 2} - x_{n + 1}) \bmod N \\
								&= (ax_{n + 1} + b - ax_n + b) \bmod N \\
								&= a(x_{n + 1} - ax_n) \bmod N \\
								&= ay_n \bmod N
					\end{flalign*}
				\]
				From the definition of the congruence relation \(N \ | \ ay_n - y_{n + 1}\). And so:
				\[
					\left.\begin{flalign*}
						N \ | \ ay_n - y_{n + 1} \\
						N \ | \ ay_{n + 1} - y_{n + 2}
					\end{flalign*}\right\rbrace
					\Longrightarrow \ N \ | \ y_{n + 1} (ay_n - y_{n + 1}) - y_n(ay_{n + 1} - y_{n + 2}) \\
				\]
				An thus:
				\[
					N \ | \ y_ny_{n + 2} - y^2_{n + 1}
				\]
				It might not seem that important, but what we have done is quite remarkable. We have managed to end up with a relation that just includes \(N\), without any of the other unknowns. Not only that, but the possibilities for \(N\) are finite! This is really important, since, if we know \(N\) then we know the modulo congruence of the LCG and calculating \(a\) is a matter of finding the multiplicative inverse of \(y_0\) in the field \(\mathbb{Z}/N\mathbb{Z}\) (more on that later).
			</p>
			<p>
				But, we have a problem... We have not found the exact value of \(N\), but rather a relation that it should satisfy. To be exact, we have \(k - 2\) divisibility relations it must satisfy:
				\[
					\begin{flalign*}
						&N \ | \ y_0y_2 - y^2_1 \\
						&N \ | \ y_1y_3 - y^2_2 \\
						&\quad... \\
						&N \ | \ y_{k - 3}y_{k - 1} - y^2_{k - 2}
					\end{flalign*}
				\]
				In other words, \(N\) must be a common divisor of the numbers \((y_0y_2 - y^2_1, \ y_1y_3 - y^2_2,\  ..., \ y_{k - 3}y_{k - 1} - y^2_{k - 2})\). For simplicity sake, let \(z_n = y_ny_{n + 2} - y^2_{n + 1}\) be the sequence of those numbers. So \(N\) must be a common divisor of all of them. But the common divisors of a set of numbers are exactly the divisors of their greatest common divisor. So, \(N\) also divides their common divisor:
				\[
					N \ | \ \gcd(z_0,\ z_1,\ ...,\ z_{k - 2})
				\]
			</p>
			<p>
				A few things to note here. First, if the above \(\gcd\) is 1, since \(N > 1\), that is a contradiction. In that case, that means that the given sequence can not be generated from a LCG. Secondly, if all \(\{z\}_n\) are \(0\), then we cannot deduce any information about \(N\). Simply put, \(N\) could be anything above the biggest number of the given sequence. This happens for example with the sequence of powers of \(2\). If we only knew the first 9 terms of the sequence \(2,\ 4,\ 8,\ ...,\ 512\), there is no way to know what \(N\) is. It could be 513 or it could be anything bigger than that.
			</p>

			<br>
			<h3>Breaking LCG</h3>
			<p>
				So far we have figured out a restriction for \(N\). That might be the correct solution, but it might also not be. We know that \(N\) must divide the \(\gcd(z_0,\ z_1,\ ..., \ z_{k - 2})\). So, let's take a guess. Let's ignore the problem for a bit and suppose, for now, that \(N = \gcd(z_0,\ z_1,\ ..., \ z_{k - 2})\) is the correct solution. Now, all we need to find is the remaining two coefficients \(a\) and \(b\). Let us first focus on \(a\).
			</p>
			<p>
				The question is: Given a sequence \(\{y\}_n\), for which \(a\) is the recursive relation \(y_{n+1} \equiv ay_n \pmod{N}\) satisfied?<br>
				We actually don't need all the values of \(\{y\}_n\). We just need the first 2: \(y_0\) and \(y_1\). We need to find a number \(a\) such that the following is true:
				\[
					y_1 \equiv ay_0 \pmod{N}
				\]
				We can now distinguish two cases:
			</p>
			<p>
				<u>Case 1:</u> \(\gcd(y_0, N) = 1\) <br>
				This is quite simple. Since \(y_0\) and \(N\) are coprime, \(y_0\) has a multiplicative inverse \(y_0^{-1}\) in \(\mathbb{Z}_N\), which we can compute quite easily with the extended euclidean algorithm. Once computed, solving for \(a\) is a matter of multiplying the above equivalence relation with \(y_0^{-1}\) and getting:
				\[
					a = y_0^{-1}y_1 \pmod{N}
				\]
			</p>
			<p>
				<u>Case 2:</u> \(\gcd(y_0, N) = d > 1\) <br>
				This is a bit more tricky. To see what is going on a bit more clearly, we are going to define a new sequence:
				\[
					u_k = (ky_0) \bmod{N}
				\]
				So \(u\) is the sequence of all multiples of \(y_0\) in \(\mathbb{Z}_N\):
				\[
					u:\ \left(0,\ y_0,\ 2y_0,\ 3y_0,\ ...,\ (N - 1)y_0\right)
				\]
				We are essentially trying to find \(y_1\) in the above sequence. That is because \(y_1\) is a multiple of \(y_0\) in \(\mathbb{Z}_N\) and \(u\) is the sequence of all such mutliples. Then, \(a\) will be the coefficient of this element of the sequence.<br>
				It is quite easy to see that the sequence \(u\) repeats itself with a period of \(\frac{N}{d}\), where \(d = \gcd(y_0, N)\). This is because \(\frac{N}{d}y_0\) is the smallest positive multiple of \(y_0\) that is \(0 \pmod{N}\). After \(\frac{N}{d}y_0\) the sequence \(u\) repeats itself from the beginning. So if we can find \(y_1\) in the sequence (i.e. if there is a solution for \(a\)), then we can find it multiple times (specifically \(d\) times).
			</p>
			<p>
				So, if \(y_1\) appears in the sequence \(u\), it will appear each time the sequence repeats. So, it will also appear in the first repetition. The period of the repetition is \(\frac{N}{d}\) and thus \(y_1\) will be in the sequence \(\left(0,\ y_0,\ 2y_0,\ 3y_0,\ ...,\ \left(\frac{N}{d} - 1\right)y_0\right)\) and \(0 \leq a \leq \frac{N}{d} - 1\).
			</p>
			<p>
				Since we have a restriction for \(a \in \{0,\ 1,\ ...,\ \frac{N}{d} - 1\}\), the idea is to now reduce \(\bmod \frac{N}{d}\) instead of \(\bmod N\). Observe the following:
				\[
					\begin{flalign*}
						&ay_0 \equiv y_1 \pmod{N} \\
						\Longleftrightarrow\quad &N \ | \ ay_0 - y_1 \\
						\Longleftrightarrow\quad &\left.\frac{N}{d} \ \right| \ a\frac{y_0 }{d}- \frac{y_1}{d} \\
						\Longleftrightarrow\quad &a\frac{y_0 }{d} \equiv \frac{y_1}{d} \mod{\frac{N}{d}}
					\end{flalign*}
				\]
				So if there exists an \(a\) such that \(ay_0 \equiv y_1 \pmod{N}\) then equivalently \(a\frac{y_0}{d} \equiv \frac{y_1}{d}\ \left(\text{mod}\ \frac{N}{d}\right)\). But \(d = \gcd(y_0, N)\) and thus \(\gcd(\frac{y_0}{d}, \frac{N}{d}) = 1\). But then \(\frac{y_0}{d}\) has a multiplicative inverse in \(\mathbb{Z}_{N/d}\). That inverse we can calculate with the extended euclidean algorithm. And thus:
				\[
					a \equiv \left(\frac{y_0}{d}\right)^{-1}\frac{y_1}{d} \quad \left(\text{mod}\ \frac{N}{d}\right)
				\]
				So we can set \(a_0 = \left(\frac{y_0}{d}\right)^{-1}\frac{y_1}{d} \bmod{N}\). This is, if we take the first repetition of the sequence \(u\) (hence \(a_0\) and not just \(a\)). Since the sequence has a period of \(\frac{N}{d}\), the other solutions are going to be in  the form:
				\[
					a_m = a_0 + m\frac{N}{d}
				\]
				for some \(m \in \mathbb{N}\). But, if we choose another solution for \(a\), that is essentially equivalent, since:
				\[
					\begin{flalign*}
						y_{n + 1} &\equiv a_m y_n \\
								&\equiv \left(a_0 + m \frac{N}{d}\right) y_n \\
								&\equiv a_0 y_n + m \frac{N}{d} y_n \\
								&\equiv a_0 y_n + m \frac{N}{d} (a_m^n y_0) \\
								&\equiv a_0 y_n + ma_m^n \frac{N}{d} y_0 \\
								&\equiv a_0 y_n \pmod{N}
					\end{flalign*}
				\]
				since \(\frac{N}{d} y_0 \equiv 0 \pmod{N}\). So, if we choose an \(a_m\) that is different from the \(a_0\) that we found, then the recursive relation still holds and thus the sequence it produces is the same. In a sence there is an equivalence between all \(a_m\) and there is no difference if we choose \(a_0\) or any other \(a_m\). From now on we are going to work with \(a_0 = \left(\frac{y_0}{d}\right)^{-1}\frac{y_1}{d} \bmod{N}\).
			</p>
			<br>
			<p>
				Now that we have a solution for \(a\), we can easily find \(b\). That is quite easy. From the first recursive step we have:
				\[
					x_1 = ax_0 + b \bmod{N}
				\]
				and thus:
				\[
					b = (x_1 - ax_0) \bmod{N}
				\]
			</p>

			<br>
			<h3>Correcting the results</h3>
			<p>
				So far we have ignored that \(N \ | \ \gcd(z_0,\ z_1,\ z_2,\ ...,\ z_{k - 2})\) and supposed that \(N\) was equal to that gcd. Now it is time to face this problem. Let \(G = \gcd(z_0,\ z_1,\ z_2,\ ...,\ z_{k - 2})\). We know, then, that \(N \ | \ G\). We also know that:
				\[
					y_{n + 1} \equiv ay_n \pmod{G}
				\]
				But \(N \ | \ G\) and thus:
				\[
					y_{n + 1} \equiv ay_n \pmod{N}
				\]
				So, the value for \(a\) we found previously, also works for all possible values of \(N\) and not just \(G\). As we essentially know a solution for \(a\), we just need to find the correct value of \(N\). This will be done with a "correction step". The idea is the following:
			</p>
			<p>
				Start with \((x_0,\ a,\ b,\ N = G)\). Then, based on those parameters calculate the first k elements the LCG (remember that k is the amount of elements we where given) and compare them with the given sequence \(\{x\}_n\). If there is a difference, then change \(N\), so that the elements become equal \(\bmod{N}\). After traversing the whole list of elements, checking them with the given sequence and correcting if necessary, we will end up with a new set of parameters for which the LCG will generate an identical sequence the one we were given. The final value of \(N\) will be the value we are looking for.<br>
				Below we have pseudocode for this algorithm:				
			</p>
			<pre id="codeblock">
				<code class="language-cpp">
a, b := the values of the parameters found from the previous step
N := G // the gcd of all z_i
// s is the array of the LCG sequence based on the parameters
s[0] := x[0]

for all i between 1 and length(x):
	s[i] := (a * s[i - 1] + b) % N
	// If we find a difference in the two sequences, we correct M
	if s[i] != x[i]:
		N = s[i] - x[i]

// After the loop, we also correct the parameters a and b
a = a % N
b = b % N</code>
			</pre>
			<p>
				If we find a difference \(s_i \neq x_i\) then we change \(N = s_i - x_i\). This works, because we know, that the correct value for \(N\) divides the one we have and that it needs to be \(s_i \equiv x_i \pmod{N} \ \Longleftrightarrow \ N \ | \ s_i - x_i\). And so \(s_i - x_i\) is the biggest number that satisfies both properties.
			</p>
			<p>
				One can easily show that, if \(s_i \neq x_i\) then \((s_i - x_i) \ | \ N\). So every correction on \(N\) reduces it to one of its divisors. That's why the correction step is consistent with the restriction that \(N \ | \ G\). Every time we "correct" \(N\), this remains true. And thus, we end up with a set of values \((a,\ b,\ N)\) which generate an identical sequence to the one given. 
			</p>
			
			<br>
			<h3>Implementation</h3>
			<p>
				Here is the pseudocode for the above algorithm, that unites both the first and second step: <br>
			</p>
			<pre id="codeblock">
				<code class="language-cpp">
Given:
	x[k] := the sequence of the first k elements
Returns:
	The parameters a, b and N that where used to generate the sequence by an LCG
Parameters used:
	y[i] := an array of k - 1 integer with the property that y[i] = x[i + 1] - x[i]
	z_i := y[i] * y[i + 2] - y[i + 1] * y[i + 1]
	G: an integer used to calculate the gcd of all z_i's
Functions used:
	gcd(a, b): returns the gcd between a and b
	inv(a, m): returns the inverse of a in mod m

for i between 0 and k - 1:
	y[i] = x[i + 1] - x[i]

// Calculating the first estimate for N
G = 0
for i between 0 and k - 1:
	z_i = y[i] * y[i + 2] - y[i + 1] * y[i + 1]
	if z_i != 0:
		G = gcd(D, z_i)

if G == 0:
	We don't have enough information to conclude anything about N

// Calculating the remaining parameters
d = gcd(y[0], G)
a = (inv(y[0] / d, G / d) * (y[1] / d)) % (G / d)
b = (x[1] - a * x[0]) % G

// correction step
N = G
for all i between 1 and length(x):
	s[i] := (a * s[i - 1] + b) % N
	// If we find a difference in the two sequences, we correct M
	if s[i] != x[i]:
		N = s[i] - x[i]

// After the loop, we also correct the parameters a and b
a = a % N
b = b % N

return a, b, N</code>
			</pre>

			<br>
			<h3>Demo</h3>
			<p>Generate an LCG sequence. Set the parameters an click to generate the sequence:</p>
			<div style="float:left">
				
				<table style="margin-left: 40px">
					<tr>
						<th style="text-align: right; padding-right: 10px;">\(x_0\):</th> <th><input type="number" id="input_x0"></th>
					</tr>
					<tr>
						<th style="text-align: right; padding-right: 10px;">\(a\):</th> <th><input type="number" id="input_a"></th>
					</tr>
					<tr>
						<th style="text-align: right; padding-right: 10px;">\(b\):</th> <th><input type="number" id="input_b"></th>
					</tr>
					<tr>
						<th style="text-align: right; padding-right: 10px;">\(N\):</th> <th><input type="number" id="input_N"></th>
					</tr>
					<tr>
						<th style="text-align: right; padding-right: 10px;">\(k\):</th> <th><input type="number" id="input_k"></th>
					</tr>
					<style>
						input[type=number] {
						-moz-appearance: textfield;
						width: 50px;
						background-color: rgb(197, 192, 183);
						box-shadow: none;
						margin: none;
						border-style: solid;
						border-width: 1px;
						border-color: gray;
						outline:none;
					}
					</style>
				</table>
			</div>
			<div style="margin-left: 30%">
				<button onclick="generate_lcg()">Generate LCG</button> <br><br>
				<output id="generating_output"></output>
				<script>
					function generate_lcg() {
						let x0 = parseInt(document.getElementById("input_x0").value);
						let a =  parseInt(document.getElementById("input_a"	).value);
						let b =  parseInt(document.getElementById("input_b"	).value);
						let N =  parseInt(document.getElementById("input_N"	).value);
						let k =  parseInt(document.getElementById("input_k"	).value);


						if (isNaN(x0) || isNaN(a) || isNaN(b) || isNaN(N) || isNaN(k)) {
							document.getElementById("generating_output").value = "Invalid input.";
							return;
						}

						let s = "Generated LCG sequence: " + x0 + " ";
						for (let i = 1; i < k; i++) {
							x0 = (a * x0 + b) % N;
							s += String(x0) + " ";
						}

						document.getElementById("generating_output").value = s;
					}
				</script>
			</div>
			<br>
			<br>
			<br>
			<br>
			<br>
			<p>Break LCG. Type the sequence in the input bellow with spaces between each number. Keep in mind that the algorithm need at least 4 number to work properly.</p>
			<input id="lcg_sequence" type="text" style="width: 70%; height:20px; float: left; margin:0 2% 0 2%">
			<button style="width:20%; float: left" onclick="break_lcg()">Break!</button>
			<br>
			<p id="breaking_output" style="width:100%; margin-bottom: 50px;"></p>
			<script>
				function modulo(a, b) {
					let m = a % b;
					if (m < 0) {
						m += Math.abs(b);
					}
					return m;
				}
				
				function gcd(a, b) {
					if (a === 0) {
						return b;
					}
					while (b != 0) {
						temp = b;
						b = modulo(a, b);
						a = temp;
					}
					return a;
				}

				function bezout_coefficients(a, b) {
					c1 = [1, 0, a]
					c2 = [0, 1, b]
					while (c2[2] != 0) {
						D = Math.floor(c1[2] / c2[2]);
						c1[0] -= c2[0] * D;
						c1[1] -= c2[1] * D;
						c1[2] -= c2[2] * D;
						c_temp = c2;
						c2 = c1;
						c1 = c_temp;
					}
					return [c1[0], c1[1]];
				}

				function get_inverse(a, m) {
					c = bezout_coefficients(a, m);
					if (c[0] * a + c[1] * m != 1) {
						return null;
					}
					return modulo(c[0], m);
				}

				function break_lcg() {
					let sequence = document.getElementById("lcg_sequence").value;
					let s = sequence.split(" ");
					let x = [];

					for (i in s) {
						if (s[i] != "") {
							let n = parseInt(s[i]);
							if (isNaN(n)) {
								document.getElementById("breaking_output").innerHTML = "Failed to parse input. Make sure that the numbers are of the correct form.";
								return;
							}
							x.push(n);
						}
					}

					let k = x.length;

					first_diff = [];
					for (let i = 0; i < k - 1; i++) {
						first_diff.push(x[i + 1] - x[i]);
					}

					D = 0;
					for (let i = 0; i < k - 3; i++) {
						D = gcd(D, first_diff[i] * first_diff[i + 2] - first_diff[i + 1] * first_diff[i + 1]);
					}

					N = Math.abs(D);
					if (N === 0) {
						a = Math.floor(first_diff[1] / first_diff[0]);
						b = x[1] - a * x[0];

						
						let is_lcg = true;
						for (let i = 0; i < k - 2; i++) {
							if (Math.floor(first_diff[i + 1] / first_diff[i]) != a) {
								console.log(i, first_diff);
								is_lcg = false;
								break;
							}
						}
						if (is_lcg) {
							document.getElementById("breaking_output").innerHTML = `We do not have enough information to determine what N, but we can confidently say that \(a = ${a},\ b = ${b}\)`;
						}
						else {
							document.getElementById("breaking_output").innerHTML = "The given sequence was not generated by a LCG";
						}
						return;
					}

					let d = gcd(first_diff[0], N);
					a = modulo(get_inverse(Math.floor(first_diff[0] / d), Math.floor(N / d)) * Math.floor(first_diff[1] / d), Math.floor(N / d))
					b = modulo(x[1] - a * x[0], N);

					let s0 = x[0];
					for (let i = 1; i < x.length; i++) {
						s0 = modulo(a * s0 + b, N);
						if (s0 < x[i]) {
							document.getElementById("breaking_output").innerHTML = "The sequence is not generated by a LCG.";
							return;
						}
						else if (s0 != x[i]) {
							N = Math.abs(s0 - x[i]);
						}
					}

					a = modulo(a, N);
					b = modulo(b, N);

					let predicted_sequence = "";
					let x0 = x[0];
					for (let i = 0; i < x.length; i++) {
						predicted_sequence += x0 + " ";
						x0 = modulo(a * x0 + b, N);
					}

					document.getElementById("breaking_output").innerHTML = `The parameters are: \(a = ${a},\ b = ${b},\ N = ${N}\)<br>The generated sequence is: ${predicted_sequence}`;
				}
			</script>
		</div>
	</div>
	<script src="../PrismJS/prismjs.js"></script>
</body>